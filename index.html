<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Dsmigrator by mbbx6spp</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Dsmigrator</h1>
          <h2>Migration tool to define, manage, and run migrations against non-RDBMS datastores or search engines.</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/mbbx6spp/dsmigrator/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/mbbx6spp/dsmigrator/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/mbbx6spp/dsmigrator" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a name="datastore-migrator" class="anchor" href="#datastore-migrator"><span class="octicon octicon-link"></span></a>Datastore Migrator</h1>

<p>Migration tool for non-RDBMS datastores. Support for different datastores
will be offered via plugin capability.</p>

<h2>
<a name="status" class="anchor" href="#status"><span class="octicon octicon-link"></span></a>Status</h2>

<p>WORK IN PROGRESS</p>

<h2>
<a name="goals" class="anchor" href="#goals"><span class="octicon octicon-link"></span></a>Goals</h2>

<p>To provide a way to:</p>

<ul>
<li>declaratively define schema <em>migrations</em>
</li>
<li>define <em>plan</em> which can be per environment</li>
<li>detect <em>status</em> of <em>plan</em> for a <em>target</em>
</li>
<li>run <em>plan</em> of <em>migrations</em> against a <em>target</em>
</li>
</ul><h2>
<a name="terminology" class="anchor" href="#terminology"><span class="octicon octicon-link"></span></a>Terminology</h2>

<ul>
<li>
<em>Schema:</em> construct in a datastore providing structure for data, e.g. index
with mappings in a search engine like ElasticSearch, table with columns and/or
column families in HBase, etc.</li>
<li>
<em>Migration:</em> atomic unit of change</li>
<li>
<em>Plan:</em> sequence of migrations</li>
<li>
<em>Status:</em> report identifying what migrations have been applied and what are pending</li>
<li>
<em>Target:</em> specific datastore typically represented by a URL</li>
</ul><h2>
<a name="motivations" class="anchor" href="#motivations"><span class="octicon octicon-link"></span></a>Motivations</h2>

<p>Here are some of the reasons not to build the same kind of thing over and
over again for the main different datastores, search engines, message
brokers, etc that require some kind of "schema" (used loosely here).</p>

<p>First of all I think the activities for each of these different types of
stores is overwhelmingly similar from an infrastructure management
perspective.</p>

<p>Secondly separating out the plan from the migrations themselves provides
a way to solve the issue of having different needs in different environments.
Where <em>environment</em> might be customer installs for single tenant applications
or different sets of nodes for staging, profiling, preproduction, and
production in multi-tenant configurations.</p>

<p>At the time I started this project I wasn't aware of a tool that provided
such a model to help solve the problems I was seeing at work where we had
HBase, ElasticSearch, Redis, Kafka, etc. which all needed to have their
"schemas" managed upon deployment of new application code (sometimes). This
leaves the application not needing to handle the setup of, say, topics on
message brokers (e.g. Kafka, RabbitMQ, etc.) and keep their focus on the
application logic.</p>

<h2>
<a name="roadmap" class="anchor" href="#roadmap"><span class="octicon octicon-link"></span></a>Roadmap</h2>

<p>This is a project basically at it's inception so there is a lot to do before
we get the first working version shipped. Namely:</p>

<p>Version 0.1 should have the ability to do the following:</p>

<ul>
<li>Provide Scala API to declaratively define migrations</li>
<li>Provide Scala API to declaratively define plans</li>
<li>Report status of a plan for the given target</li>
<li>Run plan of migrations against a target</li>
<li>Implement migration runner for HBase</li>
</ul><p>Version 0.2 should have the following capabilities in addition to 0.1:</p>

<ul>
<li>Implement migration runner for ElasticSearch 0.9.x/1.x</li>
<li>Provide Java-compatible API to define migrations</li>
<li>Provide Java-compatible API to defined plans</li>
</ul><p>TODO define next version milestones.</p>

<h2>
<a name="code-structure" class="anchor" href="#code-structure"><span class="octicon octicon-link"></span></a>Code Structure</h2>

<p>I use a less common structure to my code than many Scala projects so here is
the code structure outline and explanation:</p>

<ul>
<li>
<strong>Types:</strong> I use a <em>more</em> functional style of coding in Scala and as a
result start coding from <em><em>closed</em></em> algebraic data types (usually sum,
product, and recursive types), which define the basic elements of the
domain. These traits (types) and corresponding case classes/objects (value
constructors) can be found in the <code>Types</code> trait for namespacing. See below
for description of namespace organization.</li>
<li>
<strong>"Classes":</strong>  this does not refer to OO classes but rather typeclass
definitions. I have a trait named <code>Classes</code> which contains typeclass
definitions used to extend our basic sum, product, and recursive data
types. One such type I am using to extend my core <code>Action[A]</code> type is
<a href="https://github.com/mbbx6spp/dsmigrator/blob/master/src/main/scala/dsmigrator/classes.scala#L21-L36"><code>Group[A]</code></a>
</li>
<li>
<strong>"Instances":</strong> again this does not refer to "instances" of OO classes,
rather this refers to implementations of typeclasses for specific types.
In the trait named <code>Instances</code> you will find a number of implicits that
can be mixed in to different contexts later the allows Scala to find
the correct instance definition for a specific type of a typeclass based
on the scope it is introduced. More specific scopes have higher precedence
which means the default <code>dsmigrator</code> package instance definitions can be
overridden in applicaation/client code at a higher level if necessary.</li>
<li>
<strong>Functions:</strong> I have a trait named <code>Functions</code>, which along side the
interface to our core types and typeclasses provides the public API for
the <code>dsmigrator</code> library/toolkit.</li>
<li>
<strong>Namespacing:</strong> You will note I am using traits for namespacing primitives
that I then use to mixin to objects used for external package namespacing.
View the code in <a href="https://github.com/mbbx6spp/dsmigrator/blob/master/src/main/scala/dsmigrator/package.scala">src/main/scala/dsmigrator/package.scala</a>
to see how the <code>dsmigrator.core</code> package is constructed from traits. You
might also notice the following inline comments in the <code>Types</code> trait
that hints at a minor issue with scalac supported my preferred <code>final case</code>
style in <a href="https://github.com/mbbx6spp/dsmigrator/blob/master/src/main/scala/dsmigrator/types.scala#L5">src/main/scala/dsmigrator/types.scala</a>
</li>
</ul><h2>
<a name="faq" class="anchor" href="#faq"><span class="octicon octicon-link"></span></a>FAQ</h2>

<ul>
<li>
<strong>So the building blocks of my code are <em>closed</em>, how can we extend them?</strong>
Great question. Essentially the are only closed on construction, however,
using ad-hoc polymorphism via Scala's powerful implicits feature we can
extend these types <em>interfaces</em>. The benefit here is twofold. Firstly we
have the ability to control how values of our basic types are constructed,
which allows us to ensure they are constructed in valid forms only.
Secondly we can still extend the effective interface of the types so
we can use them in well-defined ways later without coupling the definition
of the type with all the possible ways it can be used. This is contrary
to mainstream OO techniques using interfaces that need to be "implemented"
at time of type definition as opposed to later. Note: not all OO languages
are this limited just the most used ones :(</li>
</ul><h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>This software is licensed under the BSD 3-clause license. See LICENSE file
for more information.</p>

<h2>
<a name="authors--maintainers" class="anchor" href="#authors--maintainers"><span class="octicon octicon-link"></span></a>Author(s) / Maintainer(s)</h2>

<p>So far just me, <a href="https://github.com/mbbx6spp">Susan Potter</a>.</p>

<h2>
<a name="contributors" class="anchor" href="#contributors"><span class="octicon octicon-link"></span></a>Contributor(s)</h2>

<p>Coming soon. Submit a single patch and see your name in flashing lights here.
Or something.</p>
        </section>

        <footer>
          Dsmigrator is maintained by <a href="https://github.com/mbbx6spp">mbbx6spp</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>