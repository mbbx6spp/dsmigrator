{"name":"Dsmigrator","tagline":"Migration tool to define, manage, and run migrations against non-RDBMS datastores or search engines.","body":"# Datastore Migrator\r\n\r\nMigration tool for non-RDBMS datastores. Support for different datastores\r\nwill be offered via plugin capability.\r\n\r\n## Status\r\n\r\nWORK IN PROGRESS\r\n\r\n## Goals\r\n\r\nTo provide a way to:\r\n\r\n* declaratively define schema *migrations*\r\n* define *plan* which can be per environment\r\n* detect *status* of *plan* for a *target*\r\n* run *plan* of *migrations* against a *target*\r\n\r\n## Terminology\r\n\r\n* *Schema:* construct in a datastore providing structure for data, e.g. index\r\n  with mappings in a search engine like ElasticSearch, table with columns and/or\r\n  column families in HBase, etc.\r\n* *Migration:* atomic unit of change\r\n* *Plan:* sequence of migrations\r\n* *Status:* report identifying what migrations have been applied and what are pending\r\n* *Target:* specific datastore typically represented by a URL\r\n\r\n## Motivations\r\n\r\nHere are some of the reasons not to build the same kind of thing over and\r\nover again for the main different datastores, search engines, message\r\nbrokers, etc that require some kind of \"schema\" (used loosely here).\r\n\r\nFirst of all I think the activities for each of these different types of\r\nstores is overwhelmingly similar from an infrastructure management\r\nperspective.\r\n\r\nSecondly separating out the plan from the migrations themselves provides\r\na way to solve the issue of having different needs in different environments.\r\nWhere *environment* might be customer installs for single tenant applications\r\nor different sets of nodes for staging, profiling, preproduction, and\r\nproduction in multi-tenant configurations.\r\n\r\nAt the time I started this project I wasn't aware of a tool that provided\r\nsuch a model to help solve the problems I was seeing at work where we had\r\nHBase, ElasticSearch, Redis, Kafka, etc. which all needed to have their\r\n\"schemas\" managed upon deployment of new application code (sometimes). This\r\nleaves the application not needing to handle the setup of, say, topics on\r\nmessage brokers (e.g. Kafka, RabbitMQ, etc.) and keep their focus on the\r\napplication logic.\r\n\r\n## Roadmap\r\n\r\nThis is a project basically at it's inception so there is a lot to do before\r\nwe get the first working version shipped. Namely:\r\n\r\nVersion 0.1 should have the ability to do the following:\r\n\r\n* Provide Scala API to declaratively define migrations\r\n* Provide Scala API to declaratively define plans\r\n* Report status of a plan for the given target\r\n* Run plan of migrations against a target\r\n* Implement migration runner for HBase\r\n\r\nVersion 0.2 should have the following capabilities in addition to 0.1:\r\n\r\n* Implement migration runner for ElasticSearch 0.9.x/1.x\r\n* Provide Java-compatible API to define migrations\r\n* Provide Java-compatible API to defined plans\r\n\r\nTODO define next version milestones.\r\n\r\n## Code Structure\r\n\r\nI use a less common structure to my code than many Scala projects so here is\r\nthe code structure outline and explanation:\r\n\r\n* **Types:** I use a _more_ functional style of coding in Scala and as a\r\n  result start coding from _*closed*_ algebraic data types (usually sum,\r\n  product, and recursive types), which define the basic elements of the\r\n  domain. These traits (types) and corresponding case classes/objects (value\r\n  constructors) can be found in the `Types` trait for namespacing. See below\r\n  for description of namespace organization.\r\n* **\"Classes\":**  this does not refer to OO classes but rather typeclass\r\n  definitions. I have a trait named `Classes` which contains typeclass\r\n  definitions used to extend our basic sum, product, and recursive data\r\n  types. One such type I am using to extend my core `Action[A]` type is\r\n  [`Group[A]`](https://github.com/mbbx6spp/dsmigrator/blob/master/src/main/scala/dsmigrator/classes.scala#L21-L36)\r\n* **\"Instances\":** again this does not refer to \"instances\" of OO classes,\r\n  rather this refers to implementations of typeclasses for specific types.\r\n  In the trait named `Instances` you will find a number of implicits that\r\n  can be mixed in to different contexts later the allows Scala to find\r\n  the correct instance definition for a specific type of a typeclass based\r\n  on the scope it is introduced. More specific scopes have higher precedence\r\n  which means the default `dsmigrator` package instance definitions can be\r\n  overridden in applicaation/client code at a higher level if necessary.\r\n* **Functions:** I have a trait named `Functions`, which along side the\r\n  interface to our core types and typeclasses provides the public API for\r\n  the `dsmigrator` library/toolkit.\r\n* **Namespacing:** You will note I am using traits for namespacing primitives\r\n  that I then use to mixin to objects used for external package namespacing.\r\n  View the code in [src/main/scala/dsmigrator/package.scala](https://github.com/mbbx6spp/dsmigrator/blob/master/src/main/scala/dsmigrator/package.scala)\r\n  to see how the `dsmigrator.core` package is constructed from traits. You\r\n  might also notice the following inline comments in the `Types` trait\r\n  that hints at a minor issue with scalac supported my preferred `final case`\r\n  style in [src/main/scala/dsmigrator/types.scala](https://github.com/mbbx6spp/dsmigrator/blob/master/src/main/scala/dsmigrator/types.scala#L5)\r\n\r\n## FAQ\r\n\r\n* **So the building blocks of my code are *closed*, how can we extend them?**\r\n  Great question. Essentially the are only closed on construction, however,\r\n  using ad-hoc polymorphism via Scala's powerful implicits feature we can\r\n  extend these types _interfaces_. The benefit here is twofold. Firstly we\r\n  have the ability to control how values of our basic types are constructed,\r\n  which allows us to ensure they are constructed in valid forms only.\r\n  Secondly we can still extend the effective interface of the types so\r\n  we can use them in well-defined ways later without coupling the definition\r\n  of the type with all the possible ways it can be used. This is contrary\r\n  to mainstream OO techniques using interfaces that need to be \"implemented\"\r\n  at time of type definition as opposed to later. Note: not all OO languages\r\n  are this limited just the most used ones :(\r\n\r\n## License\r\n\r\nThis software is licensed under the BSD 3-clause license. See LICENSE file\r\nfor more information.\r\n\r\n## Author(s) / Maintainer(s)\r\n\r\nSo far just me, [Susan Potter](https://github.com/mbbx6spp).\r\n\r\n## Contributor(s)\r\n\r\nComing soon. Submit a single patch and see your name in flashing lights here.\r\nOr something.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}